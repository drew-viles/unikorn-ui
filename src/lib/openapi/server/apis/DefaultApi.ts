/* tslint:disable */
/* eslint-disable */
/**
 * Kubernetes Service API
 * The Kubernetes Service API provides services that allows provisioning and life cycle management of Kubernetes clusters. The API is logically composed of authentication services, platform provider specific calls to get a set of resource types that can be then used by abstract Kubernetes Service resources to create and manage Kubernetes clusters. Requests must specify the HTML content type header.
 *
 * The version of the OpenAPI document: 0.2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApplicationBundles,
  Applications,
  ControlPlane,
  ControlPlanes,
  KubernetesCluster,
  KubernetesClusters,
  Oauth2Error,
  OpenstackAvailabilityZones,
  OpenstackExternalNetworks,
  OpenstackFlavors,
  OpenstackImages,
  OpenstackKeyPairs,
  Project,
  Projects,
  Regions,
} from '../models/index';
import {
    ApplicationBundlesFromJSON,
    ApplicationBundlesToJSON,
    ApplicationsFromJSON,
    ApplicationsToJSON,
    ControlPlaneFromJSON,
    ControlPlaneToJSON,
    ControlPlanesFromJSON,
    ControlPlanesToJSON,
    KubernetesClusterFromJSON,
    KubernetesClusterToJSON,
    KubernetesClustersFromJSON,
    KubernetesClustersToJSON,
    Oauth2ErrorFromJSON,
    Oauth2ErrorToJSON,
    OpenstackAvailabilityZonesFromJSON,
    OpenstackAvailabilityZonesToJSON,
    OpenstackExternalNetworksFromJSON,
    OpenstackExternalNetworksToJSON,
    OpenstackFlavorsFromJSON,
    OpenstackFlavorsToJSON,
    OpenstackImagesFromJSON,
    OpenstackImagesToJSON,
    OpenstackKeyPairsFromJSON,
    OpenstackKeyPairsToJSON,
    ProjectFromJSON,
    ProjectToJSON,
    ProjectsFromJSON,
    ProjectsToJSON,
    RegionsFromJSON,
    RegionsToJSON,
} from '../models/index';

export interface ApiV1ControlplanesControlPlaneNameClustersClusterNameDeleteRequest {
    controlPlaneName: string;
    clusterName: string;
}

export interface ApiV1ControlplanesControlPlaneNameClustersClusterNameGetRequest {
    controlPlaneName: string;
    clusterName: string;
}

export interface ApiV1ControlplanesControlPlaneNameClustersClusterNameKubeconfigGetRequest {
    controlPlaneName: string;
    clusterName: string;
}

export interface ApiV1ControlplanesControlPlaneNameClustersClusterNamePutRequest {
    controlPlaneName: string;
    clusterName: string;
    kubernetesCluster: KubernetesCluster;
}

export interface ApiV1ControlplanesControlPlaneNameClustersGetRequest {
    controlPlaneName: string;
}

export interface ApiV1ControlplanesControlPlaneNameClustersPostRequest {
    controlPlaneName: string;
    kubernetesCluster: KubernetesCluster;
}

export interface ApiV1ControlplanesControlPlaneNameDeleteRequest {
    controlPlaneName: string;
}

export interface ApiV1ControlplanesControlPlaneNameGetRequest {
    controlPlaneName: string;
}

export interface ApiV1ControlplanesControlPlaneNamePutRequest {
    controlPlaneName: string;
    controlPlane: ControlPlane;
}

export interface ApiV1ControlplanesPostRequest {
    controlPlane: ControlPlane;
}

export interface ApiV1ProjectsPostRequest {
    project: Project;
}

export interface ApiV1ProjectsProjectNameDeleteRequest {
    projectName: string;
}

export interface ApiV1RegionsRegionNameAvailabilityZonesBlockStorageGetRequest {
    regionName: string;
}

export interface ApiV1RegionsRegionNameAvailabilityZonesComputeGetRequest {
    regionName: string;
}

export interface ApiV1RegionsRegionNameExternalNetworksGetRequest {
    regionName: string;
}

export interface ApiV1RegionsRegionNameFlavorsGetRequest {
    regionName: string;
}

export interface ApiV1RegionsRegionNameImagesGetRequest {
    regionName: string;
}

export interface ApiV1RegionsRegionNameKeyPairsGetRequest {
    regionName: string;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Lists global application bundles for clusters.  This is used to present a choice of versions for provisioning.
     */
    async apiV1ApplicationbundlesClusterGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApplicationBundles>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/applicationbundles/cluster`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationBundlesFromJSON(jsonValue));
    }

    /**
     * Lists global application bundles for clusters.  This is used to present a choice of versions for provisioning.
     */
    async apiV1ApplicationbundlesClusterGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApplicationBundles> {
        const response = await this.apiV1ApplicationbundlesClusterGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists global application bundles for control planes.  This is used to present a choice of versions for provisioning.
     */
    async apiV1ApplicationbundlesControlPlaneGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ApplicationBundles>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/applicationbundles/controlPlane`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationBundlesFromJSON(jsonValue));
    }

    /**
     * Lists global application bundles for control planes.  This is used to present a choice of versions for provisioning.
     */
    async apiV1ApplicationbundlesControlPlaneGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ApplicationBundles> {
        const response = await this.apiV1ApplicationbundlesControlPlaneGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists applications available to be installed on clusters.
     */
    async apiV1ApplicationsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Applications>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/applications`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ApplicationsFromJSON(jsonValue));
    }

    /**
     * Lists applications available to be installed on clusters.
     */
    async apiV1ApplicationsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Applications> {
        const response = await this.apiV1ApplicationsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Delete a cluster from within a the selected control plane.
     */
    async apiV1ControlplanesControlPlaneNameClustersClusterNameDeleteRaw(requestParameters: ApiV1ControlplanesControlPlaneNameClustersClusterNameDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.controlPlaneName === null || requestParameters.controlPlaneName === undefined) {
            throw new runtime.RequiredError('controlPlaneName','Required parameter requestParameters.controlPlaneName was null or undefined when calling apiV1ControlplanesControlPlaneNameClustersClusterNameDelete.');
        }

        if (requestParameters.clusterName === null || requestParameters.clusterName === undefined) {
            throw new runtime.RequiredError('clusterName','Required parameter requestParameters.clusterName was null or undefined when calling apiV1ControlplanesControlPlaneNameClustersClusterNameDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/controlplanes/{controlPlaneName}/clusters/{clusterName}`.replace(`{${"controlPlaneName"}}`, encodeURIComponent(String(requestParameters.controlPlaneName))).replace(`{${"clusterName"}}`, encodeURIComponent(String(requestParameters.clusterName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete a cluster from within a the selected control plane.
     */
    async apiV1ControlplanesControlPlaneNameClustersClusterNameDelete(requestParameters: ApiV1ControlplanesControlPlaneNameClustersClusterNameDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1ControlplanesControlPlaneNameClustersClusterNameDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Get a cluster from within the selected control plane.
     */
    async apiV1ControlplanesControlPlaneNameClustersClusterNameGetRaw(requestParameters: ApiV1ControlplanesControlPlaneNameClustersClusterNameGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<KubernetesCluster>> {
        if (requestParameters.controlPlaneName === null || requestParameters.controlPlaneName === undefined) {
            throw new runtime.RequiredError('controlPlaneName','Required parameter requestParameters.controlPlaneName was null or undefined when calling apiV1ControlplanesControlPlaneNameClustersClusterNameGet.');
        }

        if (requestParameters.clusterName === null || requestParameters.clusterName === undefined) {
            throw new runtime.RequiredError('clusterName','Required parameter requestParameters.clusterName was null or undefined when calling apiV1ControlplanesControlPlaneNameClustersClusterNameGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/controlplanes/{controlPlaneName}/clusters/{clusterName}`.replace(`{${"controlPlaneName"}}`, encodeURIComponent(String(requestParameters.controlPlaneName))).replace(`{${"clusterName"}}`, encodeURIComponent(String(requestParameters.clusterName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KubernetesClusterFromJSON(jsonValue));
    }

    /**
     * Get a cluster from within the selected control plane.
     */
    async apiV1ControlplanesControlPlaneNameClustersClusterNameGet(requestParameters: ApiV1ControlplanesControlPlaneNameClustersClusterNameGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<KubernetesCluster> {
        const response = await this.apiV1ControlplanesControlPlaneNameClustersClusterNameGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a cluster\'s Kubernetes configuration.
     */
    async apiV1ControlplanesControlPlaneNameClustersClusterNameKubeconfigGetRaw(requestParameters: ApiV1ControlplanesControlPlaneNameClustersClusterNameKubeconfigGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.controlPlaneName === null || requestParameters.controlPlaneName === undefined) {
            throw new runtime.RequiredError('controlPlaneName','Required parameter requestParameters.controlPlaneName was null or undefined when calling apiV1ControlplanesControlPlaneNameClustersClusterNameKubeconfigGet.');
        }

        if (requestParameters.clusterName === null || requestParameters.clusterName === undefined) {
            throw new runtime.RequiredError('clusterName','Required parameter requestParameters.clusterName was null or undefined when calling apiV1ControlplanesControlPlaneNameClustersClusterNameKubeconfigGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/controlplanes/{controlPlaneName}/clusters/{clusterName}/kubeconfig`.replace(`{${"controlPlaneName"}}`, encodeURIComponent(String(requestParameters.controlPlaneName))).replace(`{${"clusterName"}}`, encodeURIComponent(String(requestParameters.clusterName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Get a cluster\'s Kubernetes configuration.
     */
    async apiV1ControlplanesControlPlaneNameClustersClusterNameKubeconfigGet(requestParameters: ApiV1ControlplanesControlPlaneNameClustersClusterNameKubeconfigGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1ControlplanesControlPlaneNameClustersClusterNameKubeconfigGetRaw(requestParameters, initOverrides);
    }

    /**
     * Update a cluster within the selected control plane.
     */
    async apiV1ControlplanesControlPlaneNameClustersClusterNamePutRaw(requestParameters: ApiV1ControlplanesControlPlaneNameClustersClusterNamePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.controlPlaneName === null || requestParameters.controlPlaneName === undefined) {
            throw new runtime.RequiredError('controlPlaneName','Required parameter requestParameters.controlPlaneName was null or undefined when calling apiV1ControlplanesControlPlaneNameClustersClusterNamePut.');
        }

        if (requestParameters.clusterName === null || requestParameters.clusterName === undefined) {
            throw new runtime.RequiredError('clusterName','Required parameter requestParameters.clusterName was null or undefined when calling apiV1ControlplanesControlPlaneNameClustersClusterNamePut.');
        }

        if (requestParameters.kubernetesCluster === null || requestParameters.kubernetesCluster === undefined) {
            throw new runtime.RequiredError('kubernetesCluster','Required parameter requestParameters.kubernetesCluster was null or undefined when calling apiV1ControlplanesControlPlaneNameClustersClusterNamePut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/controlplanes/{controlPlaneName}/clusters/{clusterName}`.replace(`{${"controlPlaneName"}}`, encodeURIComponent(String(requestParameters.controlPlaneName))).replace(`{${"clusterName"}}`, encodeURIComponent(String(requestParameters.clusterName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: KubernetesClusterToJSON(requestParameters.kubernetesCluster),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update a cluster within the selected control plane.
     */
    async apiV1ControlplanesControlPlaneNameClustersClusterNamePut(requestParameters: ApiV1ControlplanesControlPlaneNameClustersClusterNamePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1ControlplanesControlPlaneNameClustersClusterNamePutRaw(requestParameters, initOverrides);
    }

    /**
     * List all clusters within the selected control plane.
     */
    async apiV1ControlplanesControlPlaneNameClustersGetRaw(requestParameters: ApiV1ControlplanesControlPlaneNameClustersGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<KubernetesClusters>> {
        if (requestParameters.controlPlaneName === null || requestParameters.controlPlaneName === undefined) {
            throw new runtime.RequiredError('controlPlaneName','Required parameter requestParameters.controlPlaneName was null or undefined when calling apiV1ControlplanesControlPlaneNameClustersGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/controlplanes/{controlPlaneName}/clusters`.replace(`{${"controlPlaneName"}}`, encodeURIComponent(String(requestParameters.controlPlaneName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KubernetesClustersFromJSON(jsonValue));
    }

    /**
     * List all clusters within the selected control plane.
     */
    async apiV1ControlplanesControlPlaneNameClustersGet(requestParameters: ApiV1ControlplanesControlPlaneNameClustersGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<KubernetesClusters> {
        const response = await this.apiV1ControlplanesControlPlaneNameClustersGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new cluster within the selected control plane.
     */
    async apiV1ControlplanesControlPlaneNameClustersPostRaw(requestParameters: ApiV1ControlplanesControlPlaneNameClustersPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.controlPlaneName === null || requestParameters.controlPlaneName === undefined) {
            throw new runtime.RequiredError('controlPlaneName','Required parameter requestParameters.controlPlaneName was null or undefined when calling apiV1ControlplanesControlPlaneNameClustersPost.');
        }

        if (requestParameters.kubernetesCluster === null || requestParameters.kubernetesCluster === undefined) {
            throw new runtime.RequiredError('kubernetesCluster','Required parameter requestParameters.kubernetesCluster was null or undefined when calling apiV1ControlplanesControlPlaneNameClustersPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/controlplanes/{controlPlaneName}/clusters`.replace(`{${"controlPlaneName"}}`, encodeURIComponent(String(requestParameters.controlPlaneName))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: KubernetesClusterToJSON(requestParameters.kubernetesCluster),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a new cluster within the selected control plane.
     */
    async apiV1ControlplanesControlPlaneNameClustersPost(requestParameters: ApiV1ControlplanesControlPlaneNameClustersPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1ControlplanesControlPlaneNameClustersPostRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes a control plane from within the scoped project. This is a cascading operation and will delete all contained clusters.
     */
    async apiV1ControlplanesControlPlaneNameDeleteRaw(requestParameters: ApiV1ControlplanesControlPlaneNameDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.controlPlaneName === null || requestParameters.controlPlaneName === undefined) {
            throw new runtime.RequiredError('controlPlaneName','Required parameter requestParameters.controlPlaneName was null or undefined when calling apiV1ControlplanesControlPlaneNameDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/controlplanes/{controlPlaneName}`.replace(`{${"controlPlaneName"}}`, encodeURIComponent(String(requestParameters.controlPlaneName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes a control plane from within the scoped project. This is a cascading operation and will delete all contained clusters.
     */
    async apiV1ControlplanesControlPlaneNameDelete(requestParameters: ApiV1ControlplanesControlPlaneNameDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1ControlplanesControlPlaneNameDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Gets a control plane from within the scoped project.
     */
    async apiV1ControlplanesControlPlaneNameGetRaw(requestParameters: ApiV1ControlplanesControlPlaneNameGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ControlPlane>> {
        if (requestParameters.controlPlaneName === null || requestParameters.controlPlaneName === undefined) {
            throw new runtime.RequiredError('controlPlaneName','Required parameter requestParameters.controlPlaneName was null or undefined when calling apiV1ControlplanesControlPlaneNameGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/controlplanes/{controlPlaneName}`.replace(`{${"controlPlaneName"}}`, encodeURIComponent(String(requestParameters.controlPlaneName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ControlPlaneFromJSON(jsonValue));
    }

    /**
     * Gets a control plane from within the scoped project.
     */
    async apiV1ControlplanesControlPlaneNameGet(requestParameters: ApiV1ControlplanesControlPlaneNameGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ControlPlane> {
        const response = await this.apiV1ControlplanesControlPlaneNameGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Updates a control plane within the scoped project.
     */
    async apiV1ControlplanesControlPlaneNamePutRaw(requestParameters: ApiV1ControlplanesControlPlaneNamePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.controlPlaneName === null || requestParameters.controlPlaneName === undefined) {
            throw new runtime.RequiredError('controlPlaneName','Required parameter requestParameters.controlPlaneName was null or undefined when calling apiV1ControlplanesControlPlaneNamePut.');
        }

        if (requestParameters.controlPlane === null || requestParameters.controlPlane === undefined) {
            throw new runtime.RequiredError('controlPlane','Required parameter requestParameters.controlPlane was null or undefined when calling apiV1ControlplanesControlPlaneNamePut.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/controlplanes/{controlPlaneName}`.replace(`{${"controlPlaneName"}}`, encodeURIComponent(String(requestParameters.controlPlaneName))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ControlPlaneToJSON(requestParameters.controlPlane),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Updates a control plane within the scoped project.
     */
    async apiV1ControlplanesControlPlaneNamePut(requestParameters: ApiV1ControlplanesControlPlaneNamePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1ControlplanesControlPlaneNamePutRaw(requestParameters, initOverrides);
    }

    /**
     * Lists control planes within the scoped project.
     */
    async apiV1ControlplanesGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ControlPlanes>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/controlplanes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ControlPlanesFromJSON(jsonValue));
    }

    /**
     * Lists control planes within the scoped project.
     */
    async apiV1ControlplanesGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ControlPlanes> {
        const response = await this.apiV1ControlplanesGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Creates a new control plane within the scoped project.
     */
    async apiV1ControlplanesPostRaw(requestParameters: ApiV1ControlplanesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.controlPlane === null || requestParameters.controlPlane === undefined) {
            throw new runtime.RequiredError('controlPlane','Required parameter requestParameters.controlPlane was null or undefined when calling apiV1ControlplanesPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/controlplanes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ControlPlaneToJSON(requestParameters.controlPlane),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a new control plane within the scoped project.
     */
    async apiV1ControlplanesPost(requestParameters: ApiV1ControlplanesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1ControlplanesPostRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes an organization and all its resources based on the access token claims.
     */
    async apiV1OrganizationDeleteRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organization`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes an organization and all its resources based on the access token claims.
     */
    async apiV1OrganizationDelete(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationDeleteRaw(initOverrides);
    }

    /**
     * Creates a new organization based on the access token claims.
     */
    async apiV1OrganizationPostRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/organization`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a new organization based on the access token claims.
     */
    async apiV1OrganizationPost(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1OrganizationPostRaw(initOverrides);
    }

    /**
     * List all projects for the organization.
     */
    async apiV1ProjectsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Projects>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/projects`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ProjectsFromJSON(jsonValue));
    }

    /**
     * List all projects for the organization.
     */
    async apiV1ProjectsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Projects> {
        const response = await this.apiV1ProjectsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Creates a new project resource for the user\'s organization.
     */
    async apiV1ProjectsPostRaw(requestParameters: ApiV1ProjectsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.project === null || requestParameters.project === undefined) {
            throw new runtime.RequiredError('project','Required parameter requestParameters.project was null or undefined when calling apiV1ProjectsPost.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/projects`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ProjectToJSON(requestParameters.project),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Creates a new project resource for the user\'s organization.
     */
    async apiV1ProjectsPost(requestParameters: ApiV1ProjectsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1ProjectsPostRaw(requestParameters, initOverrides);
    }

    /**
     * Deletes the project associated with the authenticated user\'s scoped authorisation token. This is a cascading operation and will delete all contained control planes and clusters.
     */
    async apiV1ProjectsProjectNameDeleteRaw(requestParameters: ApiV1ProjectsProjectNameDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.projectName === null || requestParameters.projectName === undefined) {
            throw new runtime.RequiredError('projectName','Required parameter requestParameters.projectName was null or undefined when calling apiV1ProjectsProjectNameDelete.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/projects/{projectName}`.replace(`{${"projectName"}}`, encodeURIComponent(String(requestParameters.projectName))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Deletes the project associated with the authenticated user\'s scoped authorisation token. This is a cascading operation and will delete all contained control planes and clusters.
     */
    async apiV1ProjectsProjectNameDelete(requestParameters: ApiV1ProjectsProjectNameDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiV1ProjectsProjectNameDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * List all regions.
     */
    async apiV1RegionsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Regions>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/regions`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RegionsFromJSON(jsonValue));
    }

    /**
     * List all regions.
     */
    async apiV1RegionsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Regions> {
        const response = await this.apiV1RegionsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Lists all volume availability zones the authenticated user has access to.
     */
    async apiV1RegionsRegionNameAvailabilityZonesBlockStorageGetRaw(requestParameters: ApiV1RegionsRegionNameAvailabilityZonesBlockStorageGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OpenstackAvailabilityZones>> {
        if (requestParameters.regionName === null || requestParameters.regionName === undefined) {
            throw new runtime.RequiredError('regionName','Required parameter requestParameters.regionName was null or undefined when calling apiV1RegionsRegionNameAvailabilityZonesBlockStorageGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/regions/{regionName}/availability-zones/block-storage`.replace(`{${"regionName"}}`, encodeURIComponent(String(requestParameters.regionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenstackAvailabilityZonesFromJSON(jsonValue));
    }

    /**
     * Lists all volume availability zones the authenticated user has access to.
     */
    async apiV1RegionsRegionNameAvailabilityZonesBlockStorageGet(requestParameters: ApiV1RegionsRegionNameAvailabilityZonesBlockStorageGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OpenstackAvailabilityZones> {
        const response = await this.apiV1RegionsRegionNameAvailabilityZonesBlockStorageGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists all compute availability zones the authenticated user has access to.
     */
    async apiV1RegionsRegionNameAvailabilityZonesComputeGetRaw(requestParameters: ApiV1RegionsRegionNameAvailabilityZonesComputeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OpenstackAvailabilityZones>> {
        if (requestParameters.regionName === null || requestParameters.regionName === undefined) {
            throw new runtime.RequiredError('regionName','Required parameter requestParameters.regionName was null or undefined when calling apiV1RegionsRegionNameAvailabilityZonesComputeGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/regions/{regionName}/availability-zones/compute`.replace(`{${"regionName"}}`, encodeURIComponent(String(requestParameters.regionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenstackAvailabilityZonesFromJSON(jsonValue));
    }

    /**
     * Lists all compute availability zones the authenticated user has access to.
     */
    async apiV1RegionsRegionNameAvailabilityZonesComputeGet(requestParameters: ApiV1RegionsRegionNameAvailabilityZonesComputeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OpenstackAvailabilityZones> {
        const response = await this.apiV1RegionsRegionNameAvailabilityZonesComputeGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists all external networks the authenticated user has access to.
     */
    async apiV1RegionsRegionNameExternalNetworksGetRaw(requestParameters: ApiV1RegionsRegionNameExternalNetworksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OpenstackExternalNetworks>> {
        if (requestParameters.regionName === null || requestParameters.regionName === undefined) {
            throw new runtime.RequiredError('regionName','Required parameter requestParameters.regionName was null or undefined when calling apiV1RegionsRegionNameExternalNetworksGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/regions/{regionName}/external-networks`.replace(`{${"regionName"}}`, encodeURIComponent(String(requestParameters.regionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenstackExternalNetworksFromJSON(jsonValue));
    }

    /**
     * Lists all external networks the authenticated user has access to.
     */
    async apiV1RegionsRegionNameExternalNetworksGet(requestParameters: ApiV1RegionsRegionNameExternalNetworksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OpenstackExternalNetworks> {
        const response = await this.apiV1RegionsRegionNameExternalNetworksGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists all compute flavors that the authenticated user has access to
     */
    async apiV1RegionsRegionNameFlavorsGetRaw(requestParameters: ApiV1RegionsRegionNameFlavorsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OpenstackFlavors>> {
        if (requestParameters.regionName === null || requestParameters.regionName === undefined) {
            throw new runtime.RequiredError('regionName','Required parameter requestParameters.regionName was null or undefined when calling apiV1RegionsRegionNameFlavorsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/regions/{regionName}/flavors`.replace(`{${"regionName"}}`, encodeURIComponent(String(requestParameters.regionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenstackFlavorsFromJSON(jsonValue));
    }

    /**
     * Lists all compute flavors that the authenticated user has access to
     */
    async apiV1RegionsRegionNameFlavorsGet(requestParameters: ApiV1RegionsRegionNameFlavorsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OpenstackFlavors> {
        const response = await this.apiV1RegionsRegionNameFlavorsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists all compute images that the authenticated user has access to.
     */
    async apiV1RegionsRegionNameImagesGetRaw(requestParameters: ApiV1RegionsRegionNameImagesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OpenstackImages>> {
        if (requestParameters.regionName === null || requestParameters.regionName === undefined) {
            throw new runtime.RequiredError('regionName','Required parameter requestParameters.regionName was null or undefined when calling apiV1RegionsRegionNameImagesGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/regions/{regionName}/images`.replace(`{${"regionName"}}`, encodeURIComponent(String(requestParameters.regionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenstackImagesFromJSON(jsonValue));
    }

    /**
     * Lists all compute images that the authenticated user has access to.
     */
    async apiV1RegionsRegionNameImagesGet(requestParameters: ApiV1RegionsRegionNameImagesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OpenstackImages> {
        const response = await this.apiV1RegionsRegionNameImagesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Lists all key pairs the authenticated user has access to.
     */
    async apiV1RegionsRegionNameKeyPairsGetRaw(requestParameters: ApiV1RegionsRegionNameKeyPairsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OpenstackKeyPairs>> {
        if (requestParameters.regionName === null || requestParameters.regionName === undefined) {
            throw new runtime.RequiredError('regionName','Required parameter requestParameters.regionName was null or undefined when calling apiV1RegionsRegionNameKeyPairsGet.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("oauth2Authentication", []);
        }

        const response = await this.request({
            path: `/api/v1/regions/{regionName}/key-pairs`.replace(`{${"regionName"}}`, encodeURIComponent(String(requestParameters.regionName))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenstackKeyPairsFromJSON(jsonValue));
    }

    /**
     * Lists all key pairs the authenticated user has access to.
     */
    async apiV1RegionsRegionNameKeyPairsGet(requestParameters: ApiV1RegionsRegionNameKeyPairsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OpenstackKeyPairs> {
        const response = await this.apiV1RegionsRegionNameKeyPairsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
